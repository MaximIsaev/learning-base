<!-- TOC -->
* [Postgres конспект](#postgres-конспект)
  * [Транзакции](#транзакции)
  * [Индексы](#индексы)
    * [Уникальный индекс](#уникальный-индекс)
    * [Индексы на основе выражений](#индексы-на-основе-выражений)
    * [Частичные индексы](#частичные-индексы)
  * [Команды psql:](#команды-psql)
<!-- TOC -->

# Postgres конспект


## Транзакции

## Индексы

Это структура, которая строится на основе одного или нескольких значений 
конкретной таблицы и представляет собой отсортированную структуру(обычно B-tree).
В каждый элемент индекса помещается указатель на строку. При поиске, 
когда нужный элемент найден, СУБД переходит к строке по прямой ссылке из индекса

**Синтаксис** \
Создание -`CREATE INDEX имя-индекса ON имя-таблицы ( имя-столбца, ...);` \
Создание с указанием следования NULL значений - `CREATE INDEX имя-индекса ON имя-таблицы ( имя-столбца NULLS FIRST/LAST, ... );` \
Создание индекса с указанием порядка сортировки - `CREATE INDEX имя-индекса ON имя-таблицы ( имя-столбца DESC/ASC NULLS LAST, ... );` \
Удаление - `DROP INDEX имя-индекса;` \
P.S. Имя индекса можно опустить, тогда оно создается автоматически

**Автоматически индекс создается для:**
- PRIMARY KEY (Первичных ключей)
- UNIQUE constraints (Для значений, имеющих ограничение(constraint) как UNIQUE)

**Имя индекса состоит из:**
- имени таблицы и суффикса pkey (table_name_pkey) — для первичного ключа; 
- имени таблицы, имен столбцов, по которым создан индекс, и суффикса key (table_name_field_name_key)
— для уникального ключа.

**Полезные заметки**
- Индекс, созданный по столбцу, участвующему в соединении двух таблиц, 
может позволить ускорить процесс выборки записей из таблиц
- При выборке записей в отсортированном порядке индекс также может помочь, 
если сортировка выполняется по тем столбцам, по которым индекс создан
- _Селективность_ - выборка данных. _Низкая селективность_ - большое кол-во строк.
_Высокая селективность_ - небольшое кол-во строк.
- Если в SQL-запросе есть предложение ORDER BY, то индекс может позволить избежать 
этапа сортировки выбранных строк
- Однако если SQL-запрос просматривает значительную часть таблицы, то явная сортировка выбранных 
строк может оказаться быстрее, чем использование индекса
- Индексы более полезны, когда из таблицы выбирается лишь небольшая доля строк, 
т. е. при _высокой селективности_ выборки
- В случае использования предложения ORDER BY в комбинации 
с LIMIT n явная сортировка (при отсутствии индекса) потребует 
обработки всех строк таблицы ради того, чтобы определить первые n строк. 
Но если есть индекс по тем же столбцам, по которым производится сортировка ORDER BY,
то эти первые n строк могут быть извлечены непосредственно, без сканирования 
остальных строк вообще.
- По умолчанию при создании индекса NULL значения идут последними, 
т.к. применяется сортировка по возрастанию
- `NULLS FIRST` или `NULL LAST` - при создании индекса для определения порядка NULL значений 
(`CREATE INDEX имя-индекса ON имя-таблицы ( имя-столбца NULLS FIRST, ... );`)
- PostgreSQL умеет совершать обход индекса как по возрастанию, 
так и по убыванию с одинаковой эффективностью.


### Уникальный индекс
- Служит для проверки уникальности строк
- В уникальных индексах допускается наличие значений NULL
- Если уникальный индекс создан по нескольким атрибутам, 
то совпадающими считаются лишь те комбинации значений атрибутов в двух строках, 
в которых совпадают значения всех соответствующих атрибутов.

Создание - `CREATE UNIQUE INDEX имя-индекса ON имя-таблицы ( имя-столбца, ...);`

### Индексы на основе выражений
- При создании индекса можно использовать функции и скалярные значения
- Требуют больше ресурсов
- Сложные выборки выполняются быстрее, т.к. значение выражения уже вычислено
- Стоит использовать, когда время, затраченное на создание и поддержание индекса, 
компенсируется (окупается) при выполнении выборок из таблицы.

**Пример:** \
`CREATE UNIQUE INDEX index_name ON table_name ( lower( table_field ) );`

### Частичные индексы
- Используются не для все таблицы, а для части
- Чтобы СУБД использовала частичный индекс, необходимо, чтобы условие, 
записанное в запросе в предложении WHERE, соответствовало предикату индекса.
Либо условие запроса должно математически сводиться к предикату индекса, 
а система должна суметь это понять, например условие индекса > 100, 
условие в селекте > 90 не будет работать, а > 110 отработает.
- Размер частичного индекса меньше обычного, но польза от него в большинстве случаев сомнительна.
Использовать следует аккуратно.

Создание - `CREATE INDEX index_name ON table_name ( table_field ) WHERE any_table_field_expression;`





## Команды psql:
`\d имя_таблицы` - все индексы данной таблицы